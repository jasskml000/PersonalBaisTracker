/*
# [Initial Schema Setup for Personal Bias Tracker]
This script sets up the complete database schema for the application, including tables for user profiles, bias metrics, news sources, shopping patterns, behaviors, challenges, and settings. It also establishes Row Level Security (RLS) to ensure data privacy and creates a trigger to automatically provision a user profile upon sign-up.

## Query Description: [This operation will create the foundational database structure for the application. It is safe to run on a new project but could be destructive if tables with the same names already exist. No existing data will be modified as this is the initial setup.]

## Metadata:
- Schema-Category: "Structural"
- Impact-Level: "High"
- Requires-Backup: false
- Reversible: false

## Structure Details:
- **Tables Created**: profiles, bias_metrics, news_sources, shopping_patterns, behavior_entries, challenges
- **Enums Created**: bias_type, trend_type, news_category_type, challenge_type
- **Triggers Created**: on_auth_user_created

## Security Implications:
- RLS Status: Enabled on all new tables.
- Policy Changes: Yes, SELECT, INSERT, UPDATE, DELETE policies are created for each table to restrict access to the data owner.
- Auth Requirements: Policies are based on `auth.uid()`.

## Performance Impact:
- Indexes: Primary keys and foreign keys are indexed by default. Additional indexes on `user_id` are created for performance.
- Triggers: A trigger is added to the `auth.users` table, which runs once per user creation.
- Estimated Impact: Low performance impact, as queries will be filtered by the indexed `user_id`.
*/

-- 1. Create custom ENUM types
create type public.bias_type as enum ('confirmation', 'availability', 'anchoring', 'representativeness', 'optimism', 'loss_aversion');
create type public.trend_type as enum ('up', 'down', 'stable');
create type public.news_category_type as enum ('left', 'center', 'right');
create type public.challenge_type as enum ('daily', 'weekly', 'monthly');

-- 2. Create profiles table
create table public.profiles (
  id uuid not null primary key references auth.users on delete cascade,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  settings jsonb,
  constraint username_length check (char_length(username) >= 3)
);

-- 3. Set up Row Level Security (RLS) for profiles
alter table public.profiles enable row level security;
create policy "Users can view their own profile." on public.profiles for select using (auth.uid() = id);
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id);

-- 4. Create trigger to automatically create a profile for new users
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, settings)
  values (
    new.id,
    '{
      "notifications": { "email": true, "push": true, "weekly": true, "challenges": true },
      "privacy": { "dataCollection": true, "analytics": true, "shareProgress": false },
      "preferences": { "theme": "light", "language": "en", "timezone": "UTC", "currency": "USD" },
      "tracking": { "autoDetection": true, "realTimeAnalysis": true, "smartSuggestions": true }
    }'
  );
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 5. Create bias_metrics table
create table public.bias_metrics (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles on delete cascade,
  type public.bias_type not null,
  value real not null,
  trend public.trend_type not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.bias_metrics enable row level security;
create index on public.bias_metrics (user_id);
create policy "Users can manage their own bias metrics." on public.bias_metrics for all using (auth.uid() = user_id);

-- 6. Create news_sources table
create table public.news_sources (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles on delete cascade,
  name text not null,
  bias_score real not null,
  articles_read integer not null default 0,
  category public.news_category_type not null,
  reliability real not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.news_sources enable row level security;
create index on public.news_sources (user_id);
create policy "Users can manage their own news sources." on public.news_sources for all using (auth.uid() = user_id);

-- 7. Create shopping_patterns table
create table public.shopping_patterns (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles on delete cascade,
  category text not null,
  amount real not null,
  purchase_date timestamp with time zone not null,
  bias_type text not null,
  impulse boolean not null default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.shopping_patterns enable row level security;
create index on public.shopping_patterns (user_id);
create policy "Users can manage their own shopping patterns." on public.shopping_patterns for all using (auth.uid() = user_id);

-- 8. Create behavior_entries table
create table public.behavior_entries (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles on delete cascade,
  "timestamp" timestamp with time zone not null,
  activity text not null,
  biases_detected text[] not null,
  confidence real not null,
  notes text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.behavior_entries enable row level security;
create index on public.behavior_entries (user_id);
create policy "Users can manage their own behavior entries." on public.behavior_entries for all using (auth.uid() = user_id);

-- 9. Create challenges table
create table public.challenges (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles on delete cascade,
  title text not null,
  description text,
  type public.challenge_type not null,
  progress integer not null default 0,
  target integer not null default 1,
  completed boolean not null default false,
  reward text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.challenges enable row level security;
create index on public.challenges (user_id);
create policy "Users can manage their own challenges." on public.challenges for all using (auth.uid() = user_id);
